diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index 463ff4a..54a41fb 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -387,6 +387,7 @@
 /* 375 */	CALL(sys_setns)
 		CALL(sys_process_vm_readv)
 		CALL(sys_process_vm_writev)
+		CALL(sys_ext4_cowcopy)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/fs/ext4/Makefile b/fs/ext4/Makefile
index 56fd8f86..4d6c5e1 100644
--- a/fs/ext4/Makefile
+++ b/fs/ext4/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_EXT4_FS) += ext4.o
 ext4-y	:= balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o page-io.o \
 		ioctl.o namei.o super.o symlink.o hash.o resize.o extents.o \
 		ext4_jbd2.o migrate.o mballoc.o block_validity.o move_extent.o \
-		mmp.o indirect.o
+		mmp.o indirect.o cowcopy.o
 
 ext4-$(CONFIG_EXT4_FS_XATTR)		+= xattr.o xattr_user.o xattr_trusted.o
 ext4-$(CONFIG_EXT4_FS_POSIX_ACL)	+= acl.o
diff --git a/fs/ext4/cowcopy.c b/fs/ext4/cowcopy.c
new file mode 100644
index 0000000..8ebda3a
--- /dev/null
+++ b/fs/ext4/cowcopy.c
@@ -0,0 +1,103 @@
+#include <linux/fs.h>
+#include <asm-generic/errno-base.h>
+#include <asm-generic/errno.h>
+#include <linux/syscalls.h>
+#include <linux/stat.h>
+#include <linux/path.h>
+#include <linux/fs_struct.h>
+#include <linux/fdtable.h>
+#include <linux/mount.h>
+#include <linux/slab.h>
+#include <linux/xattr.h>
+#include <linux/namei.h>
+
+extern struct files_struct init_files;
+extern unsigned int full_name_hash(const unsigned char *name, unsigned int len);
+
+#define EXT4_XATTR_INDEX_USER			1
+extern int ext4_xattr_set(struct inode *inode, int name_index, const char *name, const void *value, size_t value_len, int flags);
+extern int ext4_xattr_get(struct inode *inode, int name_index, const char *name, void *buffer, size_t buffer_size);
+
+asmlinkage int sys_ext4_cowcopy(const char __user *src, const char __user *dest)
+{
+	struct path src_path,dest_path;
+	struct dentry *dest_dentry;
+	struct inode *src_inode;
+	int error;
+	int ret;
+	int result;
+	int testvalue = 1;
+
+	error = user_path(src, &src_path);
+
+	// error value indicates whether there is any error while opening the file. 0 --> no error. 
+	if (error == 0)
+	{
+		src_inode = src_path.dentry->d_inode;
+
+		// if src is a directory , return -EPERM
+		if(S_ISDIR(src_inode->i_mode))
+		{
+			return (-EPERM);
+		}
+		
+		// if src is not a regular file return -EPERM
+		if( ! S_ISREG(src_inode->i_mode) )
+		{
+			return (-EPERM);
+		}
+		
+		// if src is not in ext4 file system , return -EOPNOTSUPP
+		if(strcmp(src_inode->i_sb->s_type->name,"ext4") != 0)
+		{
+			return (-EOPNOTSUPP);
+		}
+
+
+		// if the file is open for writing, then return an EPERM
+		if(src_inode->i_writecount.counter != 0)
+ 		{
+ 			return (-EPERM);
+ 		}
+
+		// if the  dest exists, then return EEXISTS
+		error = user_path(dest, &dest_path);
+		if (error == 0)
+		{	
+			return (-EEXIST);
+		}
+		
+		// if src and dest are not on same device then return  -EXDEV
+		dest_dentry = user_path_create(-1, dest, &dest_path, 0);
+		if(src_path.mnt != dest_path.mnt)
+		{
+			return (-EXDEV);
+		}
+	
+		// lazy copy - create a hard link
+		result = vfs_link(src_path.dentry,dest_path.dentry->d_inode,dest_dentry);
+		printk("hard link creation status : %d \n", result);
+
+		mutex_unlock(&dest_path.dentry->d_inode->i_mutex);
+		
+		if(result == 0 )
+		{
+			ret = ext4_xattr_set(src_inode, EXT4_XATTR_INDEX_USER, "COW", &testvalue, 4, XATTR_CREATE);
+			if( ret != 0)
+			{
+				ret = ext4_xattr_set(src_inode, EXT4_XATTR_INDEX_USER, "COW", &testvalue, 4, XATTR_REPLACE);
+			}
+			printk("ext4_xattr_set return value: %d\n", ret);
+
+		}
+		else
+		{
+			return result;
+		}
+	}
+	else
+	{
+		return -1;
+	}
+	return 0;
+}
\ No newline at end of file
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index cb70f18..535856a 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -23,6 +23,7 @@
 #include <linux/jbd2.h>
 #include <linux/mount.h>
 #include <linux/path.h>
+#include <linux/fsnotify.h>
 #include <linux/quotaops.h>
 #include "ext4.h"
 #include "ext4_jbd2.h"
@@ -166,7 +167,7 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 	struct vfsmount *mnt = filp->f_path.mnt;
 	struct path path;
 	char buf[64], *cp;
-
+	
 	if (unlikely(!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&
 		     !(sb->s_flags & MS_RDONLY))) {
 		sbi->s_mount_flags |= EXT4_MF_MNTDIR_SAMPLED;
@@ -206,6 +207,7 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 		spin_unlock(&inode->i_lock);
 		if (unlikely(jinode != NULL))
 			jbd2_free_inode(jinode);
+
 	}
 	return dquot_file_open(inode, filp);
 }
diff --git a/fs/open.c b/fs/open.c
index 5720854..a2192f5 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -30,8 +30,10 @@
 #include <linux/fs_struct.h>
 #include <linux/ima.h>
 #include <linux/dnotify.h>
-
+#include <linux/highmem.h>
 #include "internal.h"
+#include "ext4/ext4.h"
+#include "ext4/xattr.h"
 
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
 	struct file *filp)
@@ -970,21 +972,146 @@ struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,
 }
 EXPORT_SYMBOL(file_open_root);
 
+
+int cowcopy_pages(struct inode *read_inode, struct inode *write_inode)
+{
+	struct address_space *read_page_cache, *write_page_cache;
+	struct page *read_page,*write_page;
+	int i = 0;
+	//char testoutput[10];
+	int wpresult = -1;
+	read_page_cache = read_inode->i_mapping;
+	write_page_cache = write_inode->i_mapping;
+	printk("nrpages: %lu \n", read_page_cache->nrpages);
+
+	for (i = 0; i < read_page_cache->nrpages; i++)
+	{
+
+		/*page = find_get_page(read_page_cache, i);
+		if (page == NULL)
+		{
+			
+			pages = find_or_create_page(read_page_cache, i, mapping_gfp_mask(read_page_cache));
+			error = mapping->a_ops->readpage(file, page);
+		}
+		*/
+		printk("TG: we've entered the for loop to read/write pages\n");
+		read_page = grab_cache_page(read_page_cache,i);
+		write_page = grab_cache_page(write_page_cache,i);
+		memcpy(kmap(write_page), kmap(read_page), read_inode->i_size);
+			//memcpy(testoutput, kmap(write_page), 10);
+			//testoutput[9] = '\0';
+			//printk("TG: Contents of write_page: %s\n", testoutput);
+		SetPageUptodate(write_page);
+		//set_page_dirty(write_page);
+		SetPageDirty(write_page);
+		unlock_page(read_page);
+		unlock_page(write_page);
+	}
+	ext4_mark_super_dirty(write_inode->i_sb);
+	mark_inode_dirty(write_inode);
+	//spin_unlock(&write_inode->i_lock);
+	mutex_lock(&write_inode->i_mutex);
+	wpresult = write_inode_now(write_inode, 0);
+	//spin_lock(&write_inode->i_lock);
+	mutex_unlock(&write_inode->i_mutex);
+	printk("Dirty page written? Return = %d\n", wpresult);
+
+	return 0;
+}
+
+int cowcopy(struct inode **inode, struct dentry *dentry)
+{
+	int resetflag = 0;
+	struct inode *read_inode;
+	int ret = -1 , ret_unlink = -1 , ret_cowcopy_pages = -1;
+	umode_t mode = 0644;
+
+	// unlink from previous inode
+	ret_unlink= vfs_unlink(dentry->d_parent->d_inode , dentry);\
+	printk("return for vfs_unlink:%d \n",ret_unlink);
+
+	dentry->d_inode = NULL;
+	list_del_init(&dentry->d_alias);
+	// alloc inode for new file
+
+	ret = vfs_create(dentry->d_parent->d_inode , dentry , mode , NULL );
+	printk("return value for vfs_create: %d \n", ret);
+
+	read_inode = *inode;
+
+	//copy critical fields from original inode to new inode:
+	dentry->d_inode->i_size = inode[0]->i_size;				//copying the size of the old inode (in bytes)
+	dentry->d_inode->i_blocks = inode[0]->i_blocks;			//copying the size of the old inode (in blocks)
+	dentry->d_inode->i_flags = inode[0]->i_flags;			//copying the iflags of the old inode
+	dentry->d_inode->i_writecount.counter++;				//adding a writer to the new inode
+	dentry->d_inode->i_count.counter++;						//adding a reference to the new inode
+	inode[0]->i_writecount.counter--;						//removing a writer from the old inode
+	inode[0]->i_count.counter--;							//removing a reference to the old inode
+
+	if(inode[0]->i_nlink == 1)			//if the old inode has no hardlinks remaining, it's no longer a COW file
+	{
+		ext4_xattr_set(*inode, EXT4_XATTR_INDEX_USER, "COW", &resetflag, 4, XATTR_REPLACE);
+	}
+
+	//the critical reassignment:
+	*inode = dentry->d_inode;
+	ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_USER, "COW", &resetflag, 4, XATTR_CREATE);
+
+	// readpages from src and write to dest ->  and use readpages and write pages  
+	ret_cowcopy_pages = cowcopy_pages(read_inode,*inode);
+	printk("cowcopy_pages return value: %d \n", ret_cowcopy_pages);
+
+	return ret;
+}
+
 long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
 {
 	struct open_flags op;
 	int lookup = build_open_flags(flags, mode, &op);
 	char *tmp = getname(filename);
 	int fd = PTR_ERR(tmp);
+	int ret=-1;
+	int cowcopyflag=0;
+	struct inode *inode;
 
-	if (!IS_ERR(tmp)) {
+	if (!IS_ERR(tmp)) 
+	{
 		fd = get_unused_fd_flags(flags);
-		if (fd >= 0) {
-			struct file *f = do_filp_open(dfd, tmp, &op, lookup);
-			if (IS_ERR(f)) {
+		if (fd >= 0) 
+		{
+			struct file *f; 
+			struct path cow_path;
+			int error = -1;
+			error = user_path(filename, &cow_path);
+   			if (error == 0)
+  			{
+  				inode = cow_path.dentry->d_inode;
+				if( inode != NULL)
+				{	
+					if(strcmp(inode->i_sb->s_type->name,"ext4") == 0)
+					{
+						ret = ext4_xattr_get(inode, EXT4_XATTR_INDEX_USER, "COW", &cowcopyflag, 4);
+						if( ret > 0 && cowcopyflag ==1)
+						{
+							if( ((flags & O_RDWR) == O_RDWR) || ( (flags & O_WRONLY) == O_WRONLY ) || ((flags & O_APPEND) == O_APPEND) || ((flags & O_TRUNC) == O_TRUNC))
+							{
+								ret = cowcopy(&inode,cow_path.dentry);
+								printk("cowcopy return value  =  vfs_create value: %d \n", ret);
+							}
+						}
+					}
+				}
+			}
+
+			f = do_filp_open(dfd, tmp, &op, lookup);
+			if (IS_ERR(f)) 
+			{
 				put_unused_fd(fd);
 				fd = PTR_ERR(f);
-			} else {
+			} 
+			else 
+			{
 				fsnotify_open(f);
 				fd_install(fd, f);
 			}
