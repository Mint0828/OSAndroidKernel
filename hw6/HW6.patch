diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index 463ff4a..54a41fb 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -387,6 +387,7 @@
 /* 375 */	CALL(sys_setns)
 		CALL(sys_process_vm_readv)
 		CALL(sys_process_vm_writev)
+		CALL(sys_ext4_cowcopy)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/fs/ext4/Makefile b/fs/ext4/Makefile
index 56fd8f86..4d6c5e1 100644
--- a/fs/ext4/Makefile
+++ b/fs/ext4/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_EXT4_FS) += ext4.o
 ext4-y	:= balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o page-io.o \
 		ioctl.o namei.o super.o symlink.o hash.o resize.o extents.o \
 		ext4_jbd2.o migrate.o mballoc.o block_validity.o move_extent.o \
-		mmp.o indirect.o
+		mmp.o indirect.o cowcopy.o
 
 ext4-$(CONFIG_EXT4_FS_XATTR)		+= xattr.o xattr_user.o xattr_trusted.o
 ext4-$(CONFIG_EXT4_FS_POSIX_ACL)	+= acl.o
diff --git a/fs/ext4/cowcopy.c b/fs/ext4/cowcopy.c
new file mode 100644
index 0000000..1589fda
--- /dev/null
+++ b/fs/ext4/cowcopy.c
@@ -0,0 +1,120 @@
+#include <linux/fs.h>
+#include <asm-generic/errno-base.h>
+#include <asm-generic/errno.h>
+#include <linux/syscalls.h>
+#include <linux/stat.h>
+#include <linux/path.h>
+#include <linux/fs_struct.h>
+#include <linux/fdtable.h>
+#include <linux/mount.h>
+#include <linux/slab.h>
+#include <linux/xattr.h>
+#include <linux/namei.h>
+
+extern struct files_struct init_files;
+extern unsigned int full_name_hash(const unsigned char *name, unsigned int len);
+
+#define EXT4_XATTR_INDEX_USER			1
+extern int ext4_xattr_set(struct inode *inode, int name_index, const char *name, const void *value, size_t value_len, int flags);
+extern int ext4_xattr_get(struct inode *inode, int name_index, const char *name, void *buffer, size_t buffer_size);
+
+asmlinkage int sys_ext4_cowcopy(const char __user *src, const char __user *dest)
+{
+	struct path src_path,dest_path;
+	struct dentry *dest_dentry;
+	struct inode *src_inode;
+	int error,result;
+	int ret;
+	int testvalue = 1;
+	int readtestvalue = 0;
+
+	error = user_path(src, &src_path);
+	// error value indicates whether there is any error while opening the file. 0 --> no error. 
+	if (error == 0)
+	{
+		src_inode = src_path.dentry->d_inode;
+		printk("The dentry name is %s\n", src_path.dentry->d_name.name);
+
+		// if src is a directory , return -EPERM
+		if(S_ISDIR(src_inode->i_mode))
+		{
+			printk("src is a directory\n");
+			return (-EPERM);
+		}
+		printk("src is not a directory\n");
+		
+		// if src is not a regular file return -EPERM
+		if( ! S_ISREG(src_inode->i_mode) )
+		{
+			printk("src is not a regular file\n");
+			return (-EPERM);
+		}
+		printk("src is a regular file\n");
+		
+		// if src is not in ext4 file system , return -EOPNOTSUPP
+		if(strcmp(src_inode->i_sb->s_type->name,"ext4") != 0)
+		{
+			printk("src does not use ext4. It uses %s \n",src_inode->i_sb->s_type->name );
+			return (-EOPNOTSUPP);
+		}
+		printk("src uses ext4\n");
+
+
+		// if the file is open for writing, then return an EPERM
+		if(src_inode->i_writecount.counter != 0)
+		{
+			printk("file already open for writing\n");
+			return (-EPERM);
+		}
+		printk("file not open for writing, hence can be copied\n");
+
+		// if the  dest exists, then return EEXISTS
+		error = user_path(dest, &dest_path);
+		if (error == 0)
+		{	
+			printk("destination file exists\n");
+			return (-EEXIST);
+		}
+		printk("destination file does not exist, so a COW file can be created\n");
+
+		// if src and dest are not on same device then return  -EXDEV
+		
+		dest_dentry = user_path_create(-1, dest, &dest_path, 0);
+		printk("dest_path: %s \n ", dest_path.dentry->d_name.name);
+		printk("dest_dentry : %s \n", dest_dentry->d_name.name);
+		if(src_path.mnt != dest_path.mnt)
+		{
+			printk("src device and dest not on same device\n");
+			return (-EXDEV);
+		}
+		printk("src and dest on same device\n");
+		
+
+		// lazy copy - create a hard link
+		if(src_inode->i_op == NULL) 
+		{
+			printk("i_op is not hooked into anything\n");
+		}
+		else
+		{
+			result = vfs_link(src_path.dentry,dest_path.dentry->d_inode,dest_dentry);
+			printk("hard link creation status : %d \n", result);
+		}
+
+		ret = ext4_xattr_set(src_inode, EXT4_XATTR_INDEX_USER, "COW", &testvalue, 4, XATTR_CREATE);
+		if( ret != 0)
+		{
+			ret = ext4_xattr_set(src_inode, EXT4_XATTR_INDEX_USER, "COW", &testvalue, 4, XATTR_REPLACE);
+		}
+		printk("return value: %d\n", ret);
+		ext4_xattr_get(src_inode, EXT4_XATTR_INDEX_USER, "COW", &readtestvalue, 4);
+		printk("This should be 1: %u\n", readtestvalue);
+
+	}
+	else
+	{
+		printk("source file doesnt exist\n" );
+		return -1;
+	}
+	return 0;
+}
\ No newline at end of file
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index cb70f18..318cf81 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -164,8 +164,43 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	struct vfsmount *mnt = filp->f_path.mnt;
+	struct inode *dest_inode;
+	struct dentry *current_dentry;
 	struct path path;
 	char buf[64], *cp;
+	int cowcopyflag = 0;
+	int resetflag = 0;
+
+	// if( inode -> xattr -> value == 1 && (filp -> flag == O_WRONLY or O_RDWR ) then COW copy file
+	ext4_xattr_get(inode, EXT4_XATTR_INDEX_USER, "COW", &cowcopyflag, 4);
+	if(cowcopyflag == 1 && ( filp->f_flags==O_RDWR || filp->f_flags==O_WRONLY || filp->f_flags==O_APPEND || filp->f_flags==O_TRUNC))
+	{
+		list_for_each_entry(current_dentry,&inode->i_dentry,d_alias)
+		{
+			// alloc inode for new file
+			dest_inode = new_inode(inode->i_sb);
+
+			// unlink from previous inode
+			vfs_unlink(inode,current_dentry);
+
+			// associate inode with the destination
+ 			current_dentry->d_inode = dest_inode;
+
+			// setxattr of both inode to 0
+			ext4_xattr_set(inode, EXT4_XATTR_INDEX_USER, "COW", &resetflag, 4, XATTR_CREATE);
+			ext4_xattr_set(dest_inode, EXT4_XATTR_INDEX_USER, "COW", &resetflag, 4, XATTR_CREATE);
+
+			// readpages from src and write to dest ->  and use readpages and write pages  
+			
+		}
+
+	}
+	
+	
+	
+	
+	
+
 
 	if (unlikely(!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&
 		     !(sb->s_flags & MS_RDONLY))) {
